/*
=========================================================================


						SpoutDXvideo.cpp


	A Windows Desktop Application project generated by Visual Studio
	adapted for FFmpeg video and Spout output.

	This is an example using the SpoutDX support class as a dynamic link library,
	based on the SpoutDX Windows sender example. The project is the same apart from 
	additional files and project settings.

	Differences are :

	1) SpoutDX header files are in the "SpoutDX\includes" folder
		 This file includes "SpoutDX\includes\SpoutDX.h"
		 SpoutDX.h include paths are for local files.
	2) SpoutDX libraries are in the "SpoutDX\libs" folder
	3) SpoutDX.dll must be copied to the executable folder (x64\Release)
	4) Project properties :
		SpoutDX.lib as an input for the Linker
			Project > Properties > Linker > Additional Library Directories - "SpoutDX\libs"
			Project > Properties > Linker > Input - SpoutDX.lib

	SpoutDX.lib and SpoutDX.dll can be found in the SpoutDX\libs folder.
	Build is Visual Studio 2022 x64 /MD. For other configurations, the library files
	can be rebuilt to match with CMake. Refer to the SpoutSDK for reference.

	SpoutDX.dll and the complete "DATA" folder must be copied to the executable folder.
	e.g. "\x64\Release"

	The example was created to show the use of SpoutDX dll. But, with video and
	dependence on FFmpeg, it is too complex	to be included in the Spout SDK.
	
	However, it may be useful for further reference

    o Using the SpoutDX library and dll.
    o Spout "SendImage" is the only sending function.
    o Command line processing.
    o FFprobe to read video file details.
    o FFmpeg with a pipe to decode video frames.
    o Windows application drag and drop.
	o Drag and drop with elevated UAC.
    o Display of video frames (see WM_PAINT).
	o Draw and position text.
	o Double buffering to avoid text flicker.
	o Fps control using Spout "HoldFps"
    
   FFmpeg loads a video and decodes individual frames to a pipe.
   Display in WM_PAINT and Spout SendImage.
   Spout is video only - no audio is produced.

   FFmpeg and FFprobe are required :
       Download binaries from : https://ffmpeg.zeranoe.com/builds/
       Choose the Windows static build
       Unzip the archive
       Copy bin\FFmpeg.exe and bin\FFprobe.exe to : DATA\FFMPEG

=========================================================================

	 Copyright(C) 2023 Lynn Jarvis.

			http://spout.zeal.co/

This program is free software : you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.If not, see < http://www.gnu.org/licenses/>.
========================================================================

*/

#include "framework.h"
#include "SpoutDXvideo.h"

#define MAX_LOADSTRING 100

// SPOUT
#include <vector>
#include <Shlwapi.h>
#include <commdlg.h>
#include <stdio.h>
#include <string>
#include <io.h>
#include "SpoutDX\includes\SpoutDX.h"

// Global Variables:
HINSTANCE hInst = NULL;                 // current instance
WCHAR szTitle[MAX_LOADSTRING]={};       // The title bar text
WCHAR szWindowClass[MAX_LOADSTRING]={}; // the main window class name

spoutDX sender;                         // Sending object
HWND g_hWnd = NULL;                     // Window handle
unsigned char *g_pixelBuffer = nullptr; // RGBA pixel buffer
unsigned char g_SenderName[256]={};     // Sender name
unsigned int  g_SenderWidth = 1280;     // Sender width (video width)
unsigned int  g_SenderHeight = 720;     // Sender height (video height)
float g_FrameRate = 30.0f;              // Video frame rate
double g_SenderFps = 0.0;               // For fps display averaging
std::string g_exePath;                  // Executable location
std::string g_ffmpegPath;               // FFmpeg location
std::string g_input;                    // Input string to FFmpeg
FILE *g_pipein = nullptr;               // Pipe for FFmpeg

// Forward declarations of functions included in this code module:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);

void Render(); // Read a frame from ffmpeg, display and send
bool OpenVideo(std::string filePath); // Open a video with FFmpeg
bool ffprobe(std::string filePath); // Get movie file information
void ShowSenderInfo(HDC hdc); // Show sender information on screen
void DrawString(std::string str, HDC hdc, COLORREF col, int xpos, int ypos); // Draw text

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR    lpCmdLine,
	_In_ int       nCmdShow)
{
	UNREFERENCED_PARAMETER(hPrevInstance);
	UNREFERENCED_PARAMETER(lpCmdLine);

	// Executable location
	char exePath[MAX_PATH]={};
	GetModuleFileNameA(NULL, exePath, MAX_PATH); // Path of the executable
	PathRemoveFileSpecA(exePath);
	g_exePath = exePath;

	HANDLE hMutex = NULL;

	// _popen will open a console window.
	// To hide the output, open a console first and then hide it.
	// An application can have only one console window.
	FILE* pCout = nullptr;
	if (AllocConsole()) freopen_s(&pCout, "CONOUT$", "w", stdout);
	ShowWindow(GetConsoleWindow(), SW_HIDE);
	// printf("SpoutDXvideo\n");

	// If using a Spout dynamic link library, a console should be created using 
	// AllocConsole() instead of OpenSpoutConsole() in order to use cout and printf.
	// If console logging is enabled using EnableSpoutLog(), printf and cout do not
	// show on the console. However, the "SpoutLog function can be used instead.

	//
	// Command line
	//
	// A video file name can be in "DATA\Scripts\aa-videoname.bat"
	// If the file is found, the appication window starts minimized.
	//
	std::string videoname; // The name in the batch file
	std::string videopath; // The full video path
	if (lpCmdLine && *lpCmdLine) {
		char cmdLine[1024]={};
		// Application uses wide strings
		wcstombs_s(NULL, cmdLine, lpCmdLine, MAX_PATH);
		// Remove double quotes
		std::string videoname = cmdLine;
		videoname.erase(std::remove(videoname.begin(), videoname.end(), '"'), videoname.end());
		// Remove trailing spaces
		size_t pos = videoname.find_last_not_of("\n");
		videoname = (pos == std::string::npos) ? "" : videoname.substr(0, pos + 1);
		// Remove preceding backslash
		pos = videoname.find_first_of("\\");
		if (pos != std::string::npos && pos == 0) {
			videoname = videoname.substr(pos+1);
		}

		if (PathFileExistsA(videoname.c_str())) {
			// Full fath found
			videopath = videoname;
		}
		else {
			// Try the executable folder
			videopath = g_exePath;
			videopath += "\\";
			videopath += videoname;
			if (!PathFileExistsA(videopath.c_str())) {
				// Try the DATA\Video folder
				videopath = g_exePath;
				videopath += "\\DATA\\Videos\\";
				videopath += videoname;
				if (!PathFileExistsA(videopath.c_str())) {
					// The path does not exist
					videopath.clear();
				}
			}
		}
	}
		
	// Initialize global strings
	LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadStringW(hInstance, IDC_WINSPOUTDX, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// If a movie file path was found, minimize the window.
	int nShow = nCmdShow;
	if (!videopath.empty()) {
		nShow = SW_MINIMIZE;
	}

	// Perform application initialization:
	if (!InitInstance(hInstance, nShow))
	{
		if (hMutex) ReleaseMutex(hMutex);
		return FALSE;
	}

	// FFmpeg location - \DATA\FFMPEG
	g_ffmpegPath = g_exePath;
	g_ffmpegPath += "\\DATA\\FFMPEG\\ffmpeg.exe";
	if (_access(g_ffmpegPath.c_str(), 0) == -1) {
		MessageBoxA(NULL, "FFmpeg not found", "Warning", MB_OK | MB_TOPMOST);
		if (hMutex) ReleaseMutex(hMutex);
		return FALSE;
	}

	// Look for FFprobe.exe
	std::string ffpath = g_exePath;
	ffpath += "\\DATA\\FFMPEG\\ffprobe.exe";
	if (_access(ffpath.c_str(), 0) == -1) {
		MessageBoxA(NULL, "FFprobe not found", "Warning", MB_OK | MB_TOPMOST);
		if (hMutex) ReleaseMutex(hMutex);
		return false;
	}

	// Default sender format is BGRA.
	// The same format must also be specifed for FFmpeg video data (see OpenVideo).
	// The sender format must be changed to match.
	sender.SetSenderFormat(DXGI_FORMAT_B8G8R8A8_UNORM);

	//
	// Give the sender a name
	//
	// If no name is specified, the executable name is used
	// the name is incremented "_1", "_2" etc if it already exists
	sender.SetSenderName("Spout video sender");

	// Adjust the caption in case of multiple senders of the same name
	SetWindowTextA(g_hWnd, sender.GetName());

	// Play the movie if found in "aa-video.bat"
	if (!videopath.empty()) {
		if (!OpenVideo(videopath.c_str())) {
			ShowWindow(g_hWnd, SW_SHOWNORMAL);
		}
	}

	// Main message loop:
	MSG msg = { 0 };
	while (WM_QUIT != msg.message)
	{
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		else {
			Render();
		}
	}

	// Release resources
	if (g_pipein) {
		fflush(g_pipein);
		_pclose(g_pipein);
	}
	if (g_pixelBuffer)
		delete[] g_pixelBuffer;
	sender.ReleaseSender();

	// Release the application mutex so another instance can be opened
	if (hMutex) ReleaseMutex(hMutex);

    return (int) msg.wParam;
}

void Render()
{
	// Read a frame from the FFmpeg input pipe
	if (g_pipein && g_pixelBuffer && g_SenderWidth > 0 && g_SenderHeight > 0) {

		if (fread(g_pixelBuffer, 1, g_SenderWidth*g_SenderHeight*4, g_pipein) == 0) {
			// fread = 0 means the end of the file
			// Use the same file and pixel buffer
			fflush(g_pipein);
			_pclose(g_pipein);
			g_pipein = _popen(g_input.c_str(), "rb");
		}

		// Send the pixels.
		// SendImage looks after sender creation and update.
		sender.SendImage(g_pixelBuffer, g_SenderWidth, g_SenderHeight);

	}

	// Trigger a re-paint to draw the frame - see WM_PAINT
	InvalidateRect(g_hWnd, NULL, FALSE);
	UpdateWindow(g_hWnd); // Update immediately	
						  
	// Hold the application cycle to the video frame rate
	if (g_FrameRate > 1.0f)
		sender.HoldFps((int)g_FrameRate);

}

bool OpenVideo(std::string filePath)
{
	if (filePath.empty())
		return false;

	if (_access(filePath.c_str(), 0) == -1) {
		return false;
	}

	// Get information from the movie file using ffprobe
	// to set the width, height globals
	if (!ffprobe(filePath)) {
		MessageBoxA(NULL, "FFprobe error", "Warning", MB_OK);
		return false;
	}

	if (g_pipein) {
		fflush(g_pipein);
		_pclose(g_pipein);
	}

	// Open an input pipe from ffmpeg
	g_input = g_ffmpegPath;
	// Read input at native frame rate. 
	g_input += " -re ";
	g_input += " -i ";
	g_input += "\"";
	g_input += filePath;
	g_input += "\"";
	// Specify BGRA pixel format to match the default Spout sender texture format.
	// If RGBA format is required, the sender format has to be specified as RGBA.
	// (see SetSenderFormat above).
	g_input += " -f image2pipe -vcodec rawvideo -pix_fmt bgra -";
	g_pipein = _popen(g_input.c_str(), "rb");
	if (g_pipein) {
		if (g_pixelBuffer) delete[] g_pixelBuffer;
		unsigned int buffersize = g_SenderWidth*g_SenderHeight * 4;
		g_pixelBuffer = new unsigned char[buffersize];
		return true;
	}
	else {
		MessageBoxA(NULL, "FFmpeg open failed", "Warning", MB_OK | MB_TOPMOST);
	}

	return false;
}

// Run FFprobe on a movie file and produce an ini file with the stream information
bool ffprobe(std::string videoPath)
{
	// Get information from the movie file using ffprobe and write to an ini file
	// Use a batch file with the required ffprobe options and pass the path to ShellExecute
	std::string probepath = "\"";
	probepath += g_exePath;
	probepath += "\\DATA\\FFMPEG\\probe.bat";
	probepath += "\"";

	// Input to ffprobe
	std::string input = "\"";
	input += videoPath;
	input += "\"";

	// In the batch file, %~dp0 returns the Drive and Path to the batch script

	// Open ffprobe and wait for completion
	STARTUPINFOA si = { sizeof(STARTUPINFOA) };
	si = { sizeof(STARTUPINFOA) };
	DWORD dwExitCode = 0;
	ZeroMemory((void *)&si, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_HIDE; // hide the ffprobe console window
	PROCESS_INFORMATION pi={};
	std::string cmdstring = probepath + " " + input;
	if (CreateProcessA(NULL, (LPSTR)cmdstring.c_str(), NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
		if (pi.hProcess) {
			do {
				GetExitCodeProcess(pi.hProcess, &dwExitCode);
			} while (dwExitCode == STILL_ACTIVE);
			CloseHandle(pi.hProcess);
		}
		if (pi.hThread)	CloseHandle(pi.hThread);
	}
	else {
		MessageBoxA(NULL, "FFprobe CreateProcess failed", "Warning", MB_OK | MB_TOPMOST);
		return false;
	}

	// Read the ini file produced by FFprobe to get the video information
	char initfile[MAX_PATH]={};
	strcpy_s(initfile, MAX_PATH, g_exePath.c_str());
	strcat_s(initfile, MAX_PATH, "\\DATA\\FFMPEG\\myprobe.ini");
	if (_access(initfile, 0) == -1) {
		MessageBoxA(NULL, "FFprobe ini file not found", "Warning", MB_OK | MB_TOPMOST);
		return false;
	}

	// For example :
	// [streams.stream.0]
	// width=1280
	// height = 720

	char tmp[MAX_PATH]={};
	DWORD dwResult = 0;
	g_SenderWidth = 0;
	g_SenderHeight = 0;

	// Find the first video stream
	char stream[32]={};
	for (int i=0; i<10; i++) { // arbritrary maximum
		sprintf_s(stream, 32, "streams.stream.%d", i);
		if (GetPrivateProfileStringA((LPCSTR)stream, (LPSTR)"codec_type", (LPSTR)"0", (LPSTR)tmp, 8, initfile) > 0) {
			if (strcmp(tmp, "video") == 0) {
				if (GetPrivateProfileStringA((LPCSTR)stream, (LPSTR)"width", NULL, (LPSTR)tmp, 8, initfile) > 0)
					g_SenderWidth = atoi(tmp);
				if (GetPrivateProfileStringA((LPCSTR)stream, (LPSTR)"height", NULL, (LPSTR)tmp, 8, initfile) > 0)
					g_SenderHeight = atoi(tmp);
				dwResult = GetPrivateProfileStringA((LPCSTR)"streams.stream.0", (LPSTR)"r_frame_rate", (LPSTR)"30/1", (LPSTR)tmp, 11, initfile);
				if (dwResult == 0)
					dwResult = GetPrivateProfileStringA((LPCSTR)"streams.stream.0", (LPSTR)"avg_frame_rate", (LPSTR)"30/1", (LPSTR)tmp, 11, initfile);
				break;
			}
		}
	}

	if (dwResult > 0) {
		std::string iniValue = tmp;
		auto pos = iniValue.find("/");
		double num = atof(iniValue.substr(0, pos).c_str());
		double den = atof(iniValue.substr(pos + 1, iniValue.npos).c_str());
		if (num > 0 && den > 0) {
			g_FrameRate = (float)(num / den);
		}
	}

	if (g_SenderWidth == 0 || g_SenderHeight == 0)
		return false;

	return true;
}

//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINSPOUTDX));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
	wcex.hbrBackground = CreateSolidBrush(RGB(128, 128, 128)); // Grey screen default
    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_WINSPOUTDX);
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_WINSPOUTDX));

    return RegisterClassExW(&wcex);
}

//
//   FUNCTION: InitInstance(HINSTANCE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // Store instance handle in our global variable
   HWND hWnd = NULL;

   RECT rc = { 0, 0, 640, 360 }; // Desired client size
   AdjustWindowRect(&rc, WS_CAPTION | WS_SYSMENU, TRUE);

   hWnd = CreateWindowW(szWindowClass, szTitle,
	   // Enable resize and maximize. Video output is not affected.
	   WS_OVERLAPPEDWINDOW | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_THICKFRAME,
	   CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd) {
      return FALSE;
   }

   // Centre the window on the desktop work area
   GetWindowRect(hWnd, &rc);
   RECT WorkArea={};
   int WindowPosLeft = 0;
   int WindowPosTop = 0;
   SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID)&WorkArea, 0);
   WindowPosLeft += ((WorkArea.right - WorkArea.left) - (rc.right - rc.left)) / 2;
   WindowPosTop += ((WorkArea.bottom - WorkArea.top) - (rc.bottom - rc.top)) / 2;
   MoveWindow(hWnd, WindowPosLeft, WindowPosTop, (rc.right - rc.left), (rc.bottom - rc.top), false);

   //
   // If Visual Studio is run with elevated UAC, WM_DROPFILES fails for 64 bit
   // because File Explorer is not elevated and both applications must run at the
   // same UAC level. This is not a problem if the application is opened outside of
   // Visual Studio, but this code allows development with elevated UAC level.
   //
   // This occurs only for 64bit for unknown reasons, but according to :
   // https://www.codeproject.com/Articles/104528/How-to-Enable-Drag-and-Drop-for-an-Elevated-MFC-Ap
   // You can change the User Interface Privilege Isolation (UIPI) filter on the window 
   // of the privileged application by using ChangeWindowMessageFilterEx to let file
   // dragdrop related messages be received.
   // https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-changewindowmessagefilterex
   //
   ChangeWindowMessageFilter (WM_DROPFILES, MSGFLT_ADD);
   ChangeWindowMessageFilter (WM_COPYDATA, MSGFLT_ADD);
   // Undocumented message: 0x0049, sometimes referred to as WM_COPYGLOBALDATA
   ChangeWindowMessageFilter (0x0049, MSGFLT_ADD); 
   //

   g_hWnd = hWnd;
   DragAcceptFiles(g_hWnd, TRUE);
   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Processes messages for the main window.
//
//  WM_COMMAND  - process the application menu
//  WM_PAINT    - Paint the main window
//  WM_DESTROY  - post a quit message and return
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	char szName[256]={};

    switch (message)
    {
		case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);

            // Parse the menu selections:
            switch (wmId)
            {
				case IDM_ABOUT:
					DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
					break;

				case IDM_EXIT:
					DestroyWindow(hWnd);
					break;

				default:
					return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;

		case WM_DROPFILES:
			if (DragQueryFileA((HDROP)wParam, 0xffffffff, szName, 256) > 0) {
				DragQueryFileA((HDROP)wParam, 0, szName, 256);
				OpenVideo(szName); // FFmpeg fails for unsupported formats
			}
			DragFinish((HDROP)wParam);
			break;

		case WM_PAINT:
    		{
				PAINTSTRUCT ps;
				HDC hdc = BeginPaint(hWnd, &ps);

				RECT dr ={0};
				GetClientRect(hWnd, &dr);
				
				// Create a double buffer so that both image and text
				// can be drawn o a memory DC to avoid flicker.
				HDC hdcMem = CreateCompatibleDC(hdc);
				int ndcmem = SaveDC(hdcMem);
				HBITMAP hbmMem = CreateCompatibleBitmap(hdc, (dr.right-dr.left), (dr.bottom-dr.top));
				SelectObject(hdcMem, hbmMem);

				// Draw the received image
				if (!g_pixelBuffer) {
					//
					// No data
					//
					// Inform drag and drop at screen centre
					std::string str = "DRAG AND DROP VIDEOS HERE";
					// Get the width of the string
					SIZE Size;
					GetTextExtentPoint32A(hdc, str.c_str(), (int)str.length(), (LPSIZE)&Size);
					// Center the string in the client area
					int xpos = (dr.right-dr.left)/2 - Size.cx/2;
					int ypos = (dr.bottom-dr.top)/2 - 30;
					// White text (can be any colour (00 BB GG RR) hex)
					DrawString(str, hdc, 0x00FFFFFF, xpos, ypos);
				}
				else {
					//
					// Spout sender and video data format is BGRA
					// which is suitable for Window bitmap draw
					//
					BITMAPINFO bmi;
					ZeroMemory(&bmi, sizeof(BITMAPINFO));
					bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
					bmi.bmiHeader.biSizeImage = (LONG)(g_SenderWidth * g_SenderHeight * 4); // Pixel buffer size
					bmi.bmiHeader.biWidth = (LONG)g_SenderWidth;   // Width of buffer
					bmi.bmiHeader.biHeight = -(LONG)g_SenderHeight;  // Height of buffer and bottom up
					bmi.bmiHeader.biPlanes = 1;
					bmi.bmiHeader.biBitCount = 32;
					bmi.bmiHeader.biCompression = BI_RGB;
					SetStretchBltMode(hdc, COLORONCOLOR);

					// Draw into the memory DC
					// Setting the blit mode is necessary here
					SetStretchBltMode(hdcMem, STRETCH_DELETESCANS);
					StretchDIBits(hdcMem,
						0, 0, (dr.right - dr.left), (dr.bottom - dr.top),
						0, 0, g_SenderWidth, g_SenderHeight, g_pixelBuffer,
						&bmi, DIB_RGB_COLORS, SRCCOPY);

					// Draw the sender information text
					ShowSenderInfo(hdcMem);

					// Copy the double buffer to screen
					BitBlt(hdc, 0, 0, (dr.right-dr.left), (dr.bottom-dr.top), hdcMem, 0, 0, SRCCOPY);
					
					// Clean up
					RestoreDC(hdcMem, ndcmem);
					DeleteObject(hbmMem);
					DeleteDC(hdcMem);
				}

				EndPaint(hWnd, &ps);
			}
			break;

		case WM_DESTROY:
			PostQuitMessage(0);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

void ShowSenderInfo(HDC hdc)
{
	std::string str = "Sending as : ";
	str += sender.GetName();
	str += " (";
	str += std::to_string(sender.GetWidth()); str += "x";
	str += std::to_string(sender.GetHeight());
	// Show sender fps and framecount if selected
	if (sender.GetFrame() > 0) {
		str += " fps ";
		// Average to stabilise fps display
		g_SenderFps = g_SenderFps*.85 + 0.15*sender.GetFps();
		// Round first or integer cast will truncate to the whole part
		str += std::to_string((int)(round(g_SenderFps)));
		str += " : frame  ";
		str += std::to_string(sender.GetFrame());
	}
	str += ")";

	// White text (can be any colour (00 BB GG RR) hex)
	// e.g. red = 0x000000FF
	DrawString(str, hdc, 0x00FFFFFF, 20, 20);

}

void DrawString(std::string str, HDC hdc, COLORREF col, int xpos, int ypos)
{
	HFONT hFont, hOldFont;
	hFont = (HFONT)GetStockObject(SYSTEM_FONT);
	if (hOldFont = (HFONT)SelectObject(hdc, hFont))
	{
		// Text colour
		COLORREF oldText = SetTextColor(hdc, col);
		// Transparent background
		SetBkMode(hdc, TRANSPARENT);
		// Display the text string
		TextOutA(hdc, xpos, ypos, str.c_str(), (int)str.length());
		SetTextColor(hdc, oldText);
		SelectObject(hdc, hOldFont);
	}
} // end text draw



// Message handler for about box.
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	UNREFERENCED_PARAMETER(lParam);
	char tmp[MAX_PATH]={};
	char about[1024]={};
	LPDRAWITEMSTRUCT lpdis={};
	HWND hwnd = NULL;
	HCURSOR cursorHand = NULL;

	switch (message)
	{
	case WM_INITDIALOG:

		sprintf_s(about, 256, "     Spout Video Sender");
		strcat_s(about, 1024, "\n\n\n");
		strcat_s(about, 1024, "Plays a video using FFmpeg\n");
		strcat_s(about, 1024, "and sends to any Spout receiver.\n");
		strcat_s(about, 1024, "Drag-drop a video file to play.\n");
		strcat_s(about, 1024, "Spout sends graphics only.\n\n");
		strcat_s(about, 1024, "The program window can be minimised\n");
		strcat_s(about, 1024, "and sending will continue normally.\n\n");

		SetDlgItemTextA(hDlg, IDC_ABOUT_TEXT, (LPCSTR)about);

		// Spout website hyperlink hand cursor
		cursorHand = LoadCursor(NULL, IDC_HAND);
		hwnd = GetDlgItem(hDlg, IDC_SPOUT_URL);
		SetClassLongPtrA(hwnd, GCLP_HCURSOR, (LONG_PTR)cursorHand);
		return (INT_PTR)TRUE;

	case WM_DRAWITEM:
		// The blue hyperlink
		lpdis = (LPDRAWITEMSTRUCT)lParam;
		if (lpdis->itemID == -1) break;
		SetTextColor(lpdis->hDC, RGB(6, 69, 173));
		switch (lpdis->CtlID) {
		case IDC_SPOUT_URL:
			DrawTextA(lpdis->hDC, "https://spout.zeal.co", -1, &lpdis->rcItem, DT_LEFT);
			break;
		default:
			break;
		}
		break;

	case WM_COMMAND:

		if (LOWORD(wParam) == IDC_SPOUT_URL) {
			// Open the website url
			sprintf_s(tmp, MAX_PATH, "http://spout.zeal.co");
			ShellExecuteA(hDlg, "open", tmp, NULL, NULL, SW_SHOWNORMAL);
			EndDialog(hDlg, 0);
			return (INT_PTR)TRUE;
		}

		if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
		{
			EndDialog(hDlg, LOWORD(wParam));
			return (INT_PTR)TRUE;
		}
		break;
	}
	return (INT_PTR)FALSE;
}

// That's all and there is no more ..
