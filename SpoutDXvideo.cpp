/*
=========================================================================


						SpoutDXvideo.cpp


	A Windows Desktop Application project generated by Visual Studio
	adapted for FFmpeg video and Spout output.

	This is an example using the SpoutDX support class as a dynamic link library,
	based on the SpoutDX Windows sender example. The project is the same apart from 
	additional files and project settings.

	Differences are :

	1) SpoutDX header files are in the "SpoutDX\includes" folder
		 This file includes "SpoutDX\includes\SpoutDX.h"
		 SpoutDX.h include paths are for local files.
	2) SpoutDX libraries are in the "SpoutDX\libs" folder
	3) SpoutDX.dll must be copied to the executable folder (x64\Release)
	4) Project properties :
		SpoutDX.lib as an input for the Linker
			Project > Properties > Linker > Additional Library Directories - "SpoutDX\libs"
			Project > Properties > Linker > Input - SpoutDX.lib

	SpoutDX.lib and SpoutDX.dll can be found in the SpoutDX\libs folder.
	Build is Visual Studio 2022 x64 /MD. For other configurations, the library files
	can be rebuilt to match with CMake. Refer to the SpoutSDK for reference.

	SpoutDX.dll and the complete "DATA" folder must be copied to the executable folder.
	e.g. "\x64\Release"

	The example was created to show the use of SpoutDX dll. But, with video and
	dependence on FFmpeg, it is too complex	to be included in the Spout SDK.
	
	However, it may be useful for further reference

    o Using the SpoutDX library and dll.
    o Spout "SendImage" is the only sending function.
    o Command line processing.
    o FFprobe to read video file details.
    o FFmpeg with a pipe to decode video frames.
    o Windows application drag and drop.
	o Drag and drop with elevated UAC.
    o Display of video frames (see WM_PAINT).
	o Draw and position text.
	o Double buffering to avoid text flicker.
	o Fps control using Spout "HoldFps"
    
   FFmpeg loads a video and decodes individual frames to a pipe.
   Display in WM_PAINT and Spout SendImage.
   Spout is video only - no audio is produced.

   FFmpeg and FFprobe are required :
       Download binaries from : https://ffmpeg.zeranoe.com/builds/
       Choose the Windows static build
       Unzip the archive
       Copy bin\FFmpeg.exe and bin\FFprobe.exe to : DATA\FFMPEG

=========================================================================

	 Copyright(C) 2023 Lynn Jarvis.

			http://spout.zeal.co/

This program is free software : you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.If not, see < http://www.gnu.org/licenses/>.
========================================================================

*/

#include "framework.h"
#include "SpoutDXvideo.h"

#define MAX_LOADSTRING 100

// SPOUT
#include <vector>
#include <Shlwapi.h>
#include <commdlg.h>
#include <stdio.h>
#include <string>
#include <io.h>
#include "SpoutDX\includes\SpoutDX.h"

// Global Variables:
HINSTANCE hInst = NULL;                 // current instance
WCHAR szTitle[MAX_LOADSTRING]={};       // The title bar text
WCHAR szWindowClass[MAX_LOADSTRING]={}; // the main window class name

spoutDX sender;                         // Sending object
HWND g_hWnd = NULL;                     // Window handle
HMENU g_hMenu = NULL;                   // Menu handle
unsigned char *g_pixelBuffer = nullptr; // RGBA pixel buffer
unsigned char g_SenderName[256]={};     // Sender name
unsigned int  g_SenderWidth = 1280;     // Sender width (video width)
unsigned int  g_SenderHeight = 720;     // Sender height (video height)
float g_FrameRate = 30.0f;              // Video frame rate
double g_SenderFps = 0.0;               // For fps display averaging
std::string g_exePath;                  // Executable location
std::string g_ffmpegPath;               // FFmpeg location
std::string g_input;                    // Input string to FFmpeg
FILE *g_pipein = nullptr;               // Pipe for FFmpeg

// For Windows proc callback
bool bShowInfo = true;                  // Show on-screen info
bool bTopmost = false;                  // Show topmost
bool bFullscreen = false;               // Full screen

// Globals for full screen
HWND hWndForeground = NULL;             // Current foreground window
RECT windowRect;                        // Render window rectangle
RECT clientRect;                        // Render window client rectangle
LONG_PTR dwStyle = NULL;                // Original window style
int nonFullScreenX = 0;                 // Original window X position
int nonFullScreenY = 0;                 // Original window Y position
unsigned int AddX, AddY = 0;            // Adjustment to client rect for reset of window size



// Forward declarations of functions included in this code module:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);

void Render(); // Read a frame from ffmpeg, display and send
bool OpenVideo(std::string filePath); // Open a video with FFmpeg
bool ffprobe(std::string filePath); // Get movie file information
void ShowSenderInfo(HDC hdc); // Show sender information on screen
void DrawString(std::string str, HDC hdc, COLORREF col, int xpos, int ypos); // Draw text
void doFullScreen(bool bFull); // Fullscreen display
void doTopmost(bool bTop); // Topmost dispay

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR    lpCmdLine,
	_In_ int       nCmdShow)
{
	UNREFERENCED_PARAMETER(hPrevInstance);
	UNREFERENCED_PARAMETER(lpCmdLine);

	// Executable location
	char exePath[MAX_PATH]={};
	GetModuleFileNameA(NULL, exePath, MAX_PATH); // Path of the executable
	PathRemoveFileSpecA(exePath);
	g_exePath = exePath;

	HANDLE hMutex = NULL;

	// _popen will open a console window.
	// To hide the output, open a console first and then hide it.
	// An application can have only one console window.
	FILE* pCout = nullptr;
	if (AllocConsole()) freopen_s(&pCout, "CONOUT$", "w", stdout);
	ShowWindow(GetConsoleWindow(), SW_HIDE);
	// printf("SpoutDXvideo\n");

	// If using a Spout dynamic link library, a console should be created using 
	// AllocConsole() instead of OpenSpoutConsole() in order to use cout and printf.
	// If console logging is enabled using EnableSpoutLog(), printf and cout do not
	// show on the console. However, the "SpoutLog function can be used instead.

	//
	// Command line
	//
	// Details for command line execution can be found in "\DATA\Scripts\readme.md".
	// For a quick example, double click "aa-start.vbs".
	//
	std::string videoname; // The name in the batch file
	std::string videopath; // The full video path
	if (lpCmdLine && *lpCmdLine) {
		char cmdLine[1024]={};
		// Application uses wide strings
		wcstombs_s(NULL, cmdLine, lpCmdLine, MAX_PATH);
		// Remove double quotes
		std::string videoname = cmdLine;
		videoname.erase(std::remove(videoname.begin(), videoname.end(), '"'), videoname.end());
		// Remove trailing spaces
		size_t pos = videoname.find_last_not_of("\n");
		videoname = (pos == std::string::npos) ? "" : videoname.substr(0, pos + 1);
		// Remove preceding backslash
		pos = videoname.find_first_of("\\");
		if (pos != std::string::npos && pos == 0) {
			videoname = videoname.substr(pos+1);
		}

		if (PathFileExistsA(videoname.c_str())) {
			// Full fath found
			videopath = videoname;
		}
		else {
			// Try the executable folder
			videopath = g_exePath;
			videopath += "\\";
			videopath += videoname;
			if (!PathFileExistsA(videopath.c_str())) {
				// Try the DATA\Video folder
				videopath = g_exePath;
				videopath += "\\DATA\\Videos\\";
				videopath += videoname;
				if (!PathFileExistsA(videopath.c_str())) {
					// The path does not exist
					videopath.clear();
				}
			}
		}
	}
		
	// Initialize global strings
	LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadStringW(hInstance, IDC_WINSPOUTDX, szWindowClass, MAX_LOADSTRING);
	MyRegisterClass(hInstance);

	// If a movie file path was found, minimize the window.
	int nShow = nCmdShow;
	if (!videopath.empty()) {
		nShow = SW_MINIMIZE;
	}

	// Perform application initialization:
	if (!InitInstance(hInstance, nShow))
	{
		if (hMutex) ReleaseMutex(hMutex);
		return FALSE;
	}

	// FFmpeg location - \DATA\FFMPEG
	g_ffmpegPath = g_exePath;
	g_ffmpegPath += "\\DATA\\FFMPEG\\ffmpeg.exe";
	if (_access(g_ffmpegPath.c_str(), 0) == -1) {
		MessageBoxA(NULL, "FFmpeg not found", "Warning", MB_OK | MB_TOPMOST);
		if (hMutex) ReleaseMutex(hMutex);
		return FALSE;
	}

	// Look for FFprobe.exe
	std::string ffpath = g_exePath;
	ffpath += "\\DATA\\FFMPEG\\ffprobe.exe";
	if (_access(ffpath.c_str(), 0) == -1) {
		MessageBoxA(NULL, "FFprobe not found", "Warning", MB_OK | MB_TOPMOST);
		if (hMutex) ReleaseMutex(hMutex);
		return false;
	}

	// Default sender format is BGRA.
	// The same format must also be specifed for FFmpeg video data (see OpenVideo).
	// The sender format must be changed to match.
	sender.SetSenderFormat(DXGI_FORMAT_B8G8R8A8_UNORM);

	//
	// Give the sender a name
	//
	// If no name is specified, the executable name is used
	// the name is incremented "_1", "_2" etc if it already exists
	sender.SetSenderName("Spout video sender");

	// Adjust the caption in case of multiple senders of the same name
	SetWindowTextA(g_hWnd, sender.GetName());

	// Play the movie if found in "aa-video.bat"
	if (!videopath.empty()) {
		if (!OpenVideo(videopath.c_str())) {
			ShowWindow(g_hWnd, SW_SHOWNORMAL);
		}
	}

	// Main message loop:
	MSG msg = { 0 };
	while (WM_QUIT != msg.message)
	{
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		else {
			Render();
		}
	}

	// Release resources
	if (g_pipein) {
		fflush(g_pipein);
		_pclose(g_pipein);
	}
	if (g_pixelBuffer)
		delete[] g_pixelBuffer;
	sender.ReleaseSender();

	// Release the application mutex so another instance can be opened
	if (hMutex) ReleaseMutex(hMutex);

    return (int) msg.wParam;
}

void Render()
{
	// Read a frame from the FFmpeg input pipe
	if (g_pipein && g_pixelBuffer && g_SenderWidth > 0 && g_SenderHeight > 0) {

		if (fread(g_pixelBuffer, 1, g_SenderWidth*g_SenderHeight*4, g_pipein) == 0) {
			// fread = 0 means the end of the file
			// Use the same file and pixel buffer
			fflush(g_pipein);
			_pclose(g_pipein);
			g_pipein = _popen(g_input.c_str(), "rb");
		}

		// Send the pixels.
		// SendImage looks after sender creation and update.
		sender.SendImage(g_pixelBuffer, g_SenderWidth, g_SenderHeight);

	}

	// Trigger a re-paint to draw the frame - see WM_PAINT
	InvalidateRect(g_hWnd, NULL, FALSE);
	UpdateWindow(g_hWnd); // Update immediately	
						  
	// Hold the application cycle to the video frame rate
	if (g_FrameRate > 1.0f)
		sender.HoldFps((int)g_FrameRate);

}

bool OpenVideo(std::string filePath)
{
	if (filePath.empty())
		return false;

	if (_access(filePath.c_str(), 0) == -1) {
		return false;
	}

	// Get information from the movie file using ffprobe
	// to set the width, height globals
	if (!ffprobe(filePath)) {
		MessageBoxA(NULL, "FFprobe error", "Warning", MB_OK);
		return false;
	}

	if (g_pipein) {
		fflush(g_pipein);
		_pclose(g_pipein);
	}

	// Open an input pipe from ffmpeg
	g_input = g_ffmpegPath;
	// Read input at native frame rate. 
	g_input += " -re ";
	g_input += " -i ";
	g_input += "\"";
	g_input += filePath;
	g_input += "\"";
	// Specify BGRA pixel format to match the default Spout sender texture format.
	// If RGBA format is required, the sender format has to be specified as RGBA.
	// (see SetSenderFormat above).
	g_input += " -f image2pipe -vcodec rawvideo -pix_fmt bgra -";
	g_pipein = _popen(g_input.c_str(), "rb");
	if (g_pipein) {
		if (g_pixelBuffer) delete[] g_pixelBuffer;
		unsigned int buffersize = g_SenderWidth*g_SenderHeight * 4;
		g_pixelBuffer = new unsigned char[buffersize];
		return true;
	}
	else {
		MessageBoxA(NULL, "FFmpeg open failed", "Warning", MB_OK | MB_TOPMOST);
	}

	return false;
}

// Run FFprobe on a movie file and produce an ini file with the stream information
bool ffprobe(std::string videoPath)
{
	// Get information from the movie file using ffprobe and write to an ini file
	// Use a batch file with the required ffprobe options and pass the path to ShellExecute
	std::string probepath = "\"";
	probepath += g_exePath;
	probepath += "\\DATA\\FFMPEG\\probe.bat";
	probepath += "\"";

	// Input to ffprobe
	std::string input = "\"";
	input += videoPath;
	input += "\"";

	// In the batch file, %~dp0 returns the Drive and Path to the batch script

	// Open ffprobe and wait for completion
	STARTUPINFOA si = { sizeof(STARTUPINFOA) };
	si = { sizeof(STARTUPINFOA) };
	DWORD dwExitCode = 0;
	ZeroMemory((void *)&si, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_HIDE; // hide the ffprobe console window
	PROCESS_INFORMATION pi={};
	std::string cmdstring = probepath + " " + input;
	if (CreateProcessA(NULL, (LPSTR)cmdstring.c_str(), NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
		if (pi.hProcess) {
			do {
				GetExitCodeProcess(pi.hProcess, &dwExitCode);
			} while (dwExitCode == STILL_ACTIVE);
			CloseHandle(pi.hProcess);
		}
		if (pi.hThread)	CloseHandle(pi.hThread);
	}
	else {
		MessageBoxA(NULL, "FFprobe CreateProcess failed", "Warning", MB_OK | MB_TOPMOST);
		return false;
	}

	// Read the ini file produced by FFprobe to get the video information
	char initfile[MAX_PATH]={};
	strcpy_s(initfile, MAX_PATH, g_exePath.c_str());
	strcat_s(initfile, MAX_PATH, "\\DATA\\FFMPEG\\myprobe.ini");
	if (_access(initfile, 0) == -1) {
		MessageBoxA(NULL, "FFprobe ini file not found", "Warning", MB_OK | MB_TOPMOST);
		return false;
	}

	// For example :
	// [streams.stream.0]
	// width=1280
	// height = 720

	char tmp[MAX_PATH]={};
	DWORD dwResult = 0;
	g_SenderWidth = 0;
	g_SenderHeight = 0;

	// Find the first video stream
	char stream[32]={};
	for (int i=0; i<10; i++) { // arbritrary maximum
		sprintf_s(stream, 32, "streams.stream.%d", i);
		if (GetPrivateProfileStringA((LPCSTR)stream, (LPSTR)"codec_type", (LPSTR)"0", (LPSTR)tmp, 8, initfile) > 0) {
			if (strcmp(tmp, "video") == 0) {
				if (GetPrivateProfileStringA((LPCSTR)stream, (LPSTR)"width", NULL, (LPSTR)tmp, 8, initfile) > 0)
					g_SenderWidth = atoi(tmp);
				if (GetPrivateProfileStringA((LPCSTR)stream, (LPSTR)"height", NULL, (LPSTR)tmp, 8, initfile) > 0)
					g_SenderHeight = atoi(tmp);
				dwResult = GetPrivateProfileStringA((LPCSTR)"streams.stream.0", (LPSTR)"r_frame_rate", (LPSTR)"30/1", (LPSTR)tmp, 11, initfile);
				if (dwResult == 0)
					dwResult = GetPrivateProfileStringA((LPCSTR)"streams.stream.0", (LPSTR)"avg_frame_rate", (LPSTR)"30/1", (LPSTR)tmp, 11, initfile);
				break;
			}
		}
	}

	if (dwResult > 0) {
		std::string iniValue = tmp;
		auto pos = iniValue.find("/");
		double num = atof(iniValue.substr(0, pos).c_str());
		double den = atof(iniValue.substr(pos + 1, iniValue.npos).c_str());
		if (num > 0 && den > 0) {
			g_FrameRate = (float)(num / den);
		}
	}

	if (g_SenderWidth == 0 || g_SenderHeight == 0)
		return false;

	return true;
}

//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINSPOUTDX));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
	wcex.hbrBackground = CreateSolidBrush(RGB(128, 128, 128)); // Grey screen default
    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_WINSPOUTDX);
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_WINSPOUTDX));

    return RegisterClassExW(&wcex);
}

//
//   FUNCTION: InitInstance(HINSTANCE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // Store instance handle in our global variable
   HWND hWnd = NULL;

   RECT rc = { 0, 0, 640, 360 }; // Desired client size
   AdjustWindowRect(&rc, WS_CAPTION | WS_SYSMENU, TRUE);

   hWnd = CreateWindowW(szWindowClass, szTitle,
	   // Enable resize and maximize. Video output is not affected.
	   WS_OVERLAPPEDWINDOW | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_THICKFRAME,
	   CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd) {
      return FALSE;
   }

   // Centre the window on the desktop work area
   GetWindowRect(hWnd, &rc);
   RECT WorkArea={};
   int WindowPosLeft = 0;
   int WindowPosTop = 0;
   SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID)&WorkArea, 0);
   WindowPosLeft += ((WorkArea.right - WorkArea.left) - (rc.right - rc.left)) / 2;
   WindowPosTop += ((WorkArea.bottom - WorkArea.top) - (rc.bottom - rc.top)) / 2;
   MoveWindow(hWnd, WindowPosLeft, WindowPosTop, (rc.right - rc.left), (rc.bottom - rc.top), false);

   //
   // If Visual Studio is run with elevated UAC, WM_DROPFILES fails for 64 bit
   // because File Explorer is not elevated and both applications must run at the
   // same UAC level. This is not a problem if the application is opened outside of
   // Visual Studio, but this code allows development with elevated UAC level.
   //
   // This occurs only for 64bit for unknown reasons, but according to :
   // https://www.codeproject.com/Articles/104528/How-to-Enable-Drag-and-Drop-for-an-Elevated-MFC-Ap
   // You can change the User Interface Privilege Isolation (UIPI) filter on the window 
   // of the privileged application by using ChangeWindowMessageFilterEx to let file
   // dragdrop related messages be received.
   // https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-changewindowmessagefilterex
   //
   ChangeWindowMessageFilter (WM_DROPFILES, MSGFLT_ADD);
   ChangeWindowMessageFilter (WM_COPYDATA, MSGFLT_ADD);
   // Undocumented message: 0x0049, sometimes referred to as WM_COPYGLOBALDATA
   ChangeWindowMessageFilter (0x0049, MSGFLT_ADD); 
   //

   g_hWnd = hWnd;
   g_hMenu = GetMenu(g_hWnd); // Used for full screen
   DragAcceptFiles(g_hWnd, TRUE);
   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
}

//
//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Processes messages for the main window.
//
//  WM_COMMAND  - process the application menu
//  WM_PAINT    - Paint the main window
//  WM_DESTROY  - post a quit message and return
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	char szName[256]={};

    switch (message)
    {
		case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);

            // Parse the menu selections:
            switch (wmId)
            {
				case IDM_ABOUT:
					DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
					break;

				case IDM_EXIT:
					DestroyWindow(hWnd);
					break;
				case IDM_TOPMOST:
					bTopmost = !bTopmost;
					doTopmost(bTopmost);
					if (bTopmost)
						CheckMenuItem(g_hMenu, IDM_TOPMOST, MF_BYCOMMAND | MF_CHECKED);
					else
						CheckMenuItem(g_hMenu, IDM_TOPMOST, MF_BYCOMMAND | MF_UNCHECKED);
					break;
				case IDM_FULLSCREEN:
					bFullscreen = true;
					doFullScreen(bFullscreen);
					break;
				default:
					return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;

		case WM_KEYUP:
		{
			// Don't use key down in case of repeats
			switch (wParam) {
				case VK_ESCAPE:
					// Console
					printf("VK_ESCAPE\n");
					if (bFullscreen) {
						bFullscreen = false;
						doFullScreen(bFullscreen);
					}
					break;
				// 0x46 F
				case 0x46:
					bFullscreen = !bFullscreen;
					doFullScreen(bFullscreen);
					break;
				// 0x20 SPACEBAR
				case 0x20:
					bShowInfo = !bShowInfo;
					break;
				default:
					break;
			}
			break;

		}
		break;

		case WM_DROPFILES:
			if (DragQueryFileA((HDROP)wParam, 0xffffffff, szName, 256) > 0) {
				DragQueryFileA((HDROP)wParam, 0, szName, 256);
				OpenVideo(szName); // FFmpeg fails for unsupported formats
			}
			DragFinish((HDROP)wParam);
			break;

		case WM_PAINT:
    		{
				PAINTSTRUCT ps;
				HDC hdc = BeginPaint(hWnd, &ps);

				RECT dr ={0};
				GetClientRect(hWnd, &dr);
				
				// Create a double buffer so that both image and text
				// can be drawn o a memory DC to avoid flicker.
				HDC hdcMem = CreateCompatibleDC(hdc);
				int ndcmem = SaveDC(hdcMem);
				HBITMAP hbmMem = CreateCompatibleBitmap(hdc, (dr.right-dr.left), (dr.bottom-dr.top));
				SelectObject(hdcMem, hbmMem);

				// Draw the received image
				if (!g_pixelBuffer) {
					//
					// No data
					//
					// Inform drag and drop at screen centre
					if (!bFullscreen) {
						std::string str = "DRAG AND DROP VIDEOS HERE";
						// Get the width of the string
						SIZE Size;
						GetTextExtentPoint32A(hdc, str.c_str(), (int)str.length(), (LPSIZE)&Size);
						// Center the string in the client area
						int xpos = (dr.right-dr.left)/2 - Size.cx/2;
						int ypos = (dr.bottom-dr.top)/2 - 30;
						// White text (can be any colour (00 BB GG RR) hex)
						DrawString(str, hdc, 0x00FFFFFF, xpos, ypos);
					}
				}
				else {
					//
					// Spout sender and video data format is BGRA
					// which is suitable for Window bitmap draw
					//
					BITMAPINFO bmi;
					ZeroMemory(&bmi, sizeof(BITMAPINFO));
					bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
					bmi.bmiHeader.biSizeImage = (LONG)(g_SenderWidth * g_SenderHeight * 4); // Pixel buffer size
					bmi.bmiHeader.biWidth = (LONG)g_SenderWidth;   // Width of buffer
					bmi.bmiHeader.biHeight = -(LONG)g_SenderHeight;  // Height of buffer and bottom up
					bmi.bmiHeader.biPlanes = 1;
					bmi.bmiHeader.biBitCount = 32;
					bmi.bmiHeader.biCompression = BI_RGB;
					SetStretchBltMode(hdc, COLORONCOLOR);

					// Draw into the memory DC
					// Setting the blit mode is necessary here
					SetStretchBltMode(hdcMem, STRETCH_DELETESCANS);
					StretchDIBits(hdcMem,
						0, 0, (dr.right - dr.left), (dr.bottom - dr.top),
						0, 0, g_SenderWidth, g_SenderHeight, g_pixelBuffer,
						&bmi, DIB_RGB_COLORS, SRCCOPY);

					// Draw the sender information text
					// Unless full screen or no show by space bar
					if (bShowInfo && !bFullscreen)
						ShowSenderInfo(hdcMem);

					// Copy the double buffer to screen
					BitBlt(hdc, 0, 0, (dr.right-dr.left), (dr.bottom-dr.top), hdcMem, 0, 0, SRCCOPY);
					
					// Clean up
					RestoreDC(hdcMem, ndcmem);
					DeleteObject(hbmMem);
					DeleteDC(hdcMem);
				}

				EndPaint(hWnd, &ps);
			}
			break;

		case WM_DESTROY:
			PostQuitMessage(0);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

void ShowSenderInfo(HDC hdc)
{
	std::string str = "Sending as : ";
	str += sender.GetName();
	str += " (";
	str += std::to_string(sender.GetWidth()); str += "x";
	str += std::to_string(sender.GetHeight());
	// Show sender fps and framecount if selected
	if (sender.GetFrame() > 0) {
		str += " fps ";
		// Average to stabilise fps display
		g_SenderFps = g_SenderFps*.85 + 0.15*sender.GetFps();
		// Round first or integer cast will truncate to the whole part
		str += std::to_string((int)(round(g_SenderFps)));
		str += " : frame  ";
		str += std::to_string(sender.GetFrame());
	}
	str += ")";

	// White text (can be any colour (00 BB GG RR) hex)
	// e.g. red = 0x000000FF
	DrawString(str, hdc, 0x00FFFFFF, 20, 20);

	str = "f - fullscreen : Space - hide info";
	DrawString(str, hdc, 0x00FFFFFF, 20, 40);


}

void DrawString(std::string str, HDC hdc, COLORREF col, int xpos, int ypos)
{
	HFONT hFont, hOldFont;
	hFont = (HFONT)GetStockObject(SYSTEM_FONT);
	if (hOldFont = (HFONT)SelectObject(hdc, hFont))
	{
		// Text colour
		COLORREF oldText = SetTextColor(hdc, col);
		// Transparent background
		SetBkMode(hdc, TRANSPARENT);
		// Display the text string
		TextOutA(hdc, xpos, ypos, str.c_str(), (int)str.length());
		SetTextColor(hdc, oldText);
		SelectObject(hdc, hOldFont);
	}
} // end text draw


//--------------------------------------------------------------
void doFullScreen(bool bFullscreen)
{
	RECT rectTaskBar = {};
	HWND hWndTaskBar = NULL;
	HWND hWndMode = NULL;

	if (bFullscreen) {

		//
		// Set full screen
		//

		// Get the current top window
		hWndForeground = GetForegroundWindow();

		// Preserve current window size values
		GetWindowRect(g_hWnd, &windowRect);
		GetClientRect(g_hWnd, &clientRect);

		// Get the client/window adjustment values
		AddX = (windowRect.right - windowRect.left) - (clientRect.right - clientRect.left);
		AddY = (windowRect.bottom - windowRect.top) - (clientRect.bottom - clientRect.top);

		// Get current client window size for return
		nonFullScreenX = (clientRect.right - clientRect.left);
		nonFullScreenY = (clientRect.bottom - clientRect.top);

		// Remove caption, borders etc.
		dwStyle = GetWindowLongPtrA(g_hWnd, GWL_STYLE);
		SetWindowLongPtrA(g_hWnd, GWL_STYLE, WS_VISIBLE); // no other styles but visible

		// Remove the menu
		SetMenu(g_hWnd, NULL);

		// Get the taskbar window handle
		hWndTaskBar = FindWindowA("Shell_TrayWnd", "");
		GetWindowRect(g_hWnd, &rectTaskBar);

		// Put the taskbar lowest Z order
		SetWindowPos(hWndTaskBar, HWND_NOTOPMOST, 0, 0, (rectTaskBar.right - rectTaskBar.left), (rectTaskBar.bottom - rectTaskBar.top), SWP_NOMOVE | SWP_NOSIZE);

		// Allow for multiple monitors
		HMONITOR monitor = MonitorFromWindow(g_hWnd, MONITOR_DEFAULTTOPRIMARY);
		MONITORINFO mi;
		mi.cbSize = sizeof(mi);
		GetMonitorInfoA(monitor, &mi);
		int x = (int)mi.rcMonitor.left;
		int y = (int)mi.rcMonitor.top;
		int w = (int)(mi.rcMonitor.right - mi.rcMonitor.left); // rcMonitor dimensions are LONG
		int h = (int)(mi.rcMonitor.bottom - mi.rcMonitor.top);

		// Noted slowdown ~28fps with AMD graphics with one SetWindowPos
		// and freeze of keystrokes if two. Increase height by 1 for SetWindowPos
		// seems to fix it ! ???
		SetWindowPos(g_hWnd, HWND_TOP, x, y, w, h+1, SWP_SHOWWINDOW);
		ShowCursor(FALSE);

		// Necessary to detect keys
		SetFocus(g_hWnd);

	} // endif bFullscreen
	else {

		//
		// Exit full screen
		//

		// Restore original style
		SetWindowLongPtrA(g_hWnd, GWL_STYLE, dwStyle);

		// Restore the menu
		SetMenu(g_hWnd, g_hMenu);

		// Restore topmost state
		if (bTopmost)
			hWndMode = HWND_TOPMOST;
		else
			hWndMode = HWND_TOP;

		// Restore our window
		SetWindowPos(g_hWnd, hWndMode, windowRect.left, windowRect.top, nonFullScreenX + AddX, nonFullScreenY + AddY, SWP_SHOWWINDOW);

		// Reset the window that was top before - could be ours
		if (GetWindowLong(hWndForeground, GWL_EXSTYLE) & WS_EX_TOPMOST)
			SetWindowPos(hWndForeground, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
		else
			SetWindowPos(hWndForeground, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

		DrawMenuBar(g_hWnd);

		// Show cursor for all modes
		ShowCursor(TRUE);
		SetFocus(g_hWnd);

	} // endif not bFullscreen

}


//--------------------------------------------------------------
void doTopmost(bool bTop)
{
	if (bTop) {
		// Get the current top window for return
		hWndForeground = GetForegroundWindow();
		// Set this window topmost
		SetWindowPos(g_hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
		ShowWindow(g_hWnd, SW_SHOW);
	}
	else {
		SetWindowPos(g_hWnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
		ShowWindow(g_hWnd, SW_SHOW);
		// Reset the window that was topmost before
		if (GetWindowLong(hWndForeground, GWL_EXSTYLE) & WS_EX_TOPMOST)
			SetWindowPos(hWndForeground, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
		else
			SetWindowPos(hWndForeground, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
	}
} // end doTopmost



// Message handler for about box.
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	UNREFERENCED_PARAMETER(lParam);
	char tmp[MAX_PATH]={};
	char about[1024]={};
	LPDRAWITEMSTRUCT lpdis={};
	HWND hwnd = NULL;
	HCURSOR cursorHand = NULL;

	switch (message)
	{
	case WM_INITDIALOG:

		sprintf_s(about, 256, "     Spout Video Sender");
		strcat_s(about, 1024, "\n\n\n");
		strcat_s(about, 1024, "Plays a video using FFmpeg\n");
		strcat_s(about, 1024, "and sends to any Spout receiver.\n");
		strcat_s(about, 1024, "Drag-drop a video file to play.\n");
		strcat_s(about, 1024, "Spout sends graphics only.\n\n");
		strcat_s(about, 1024, "The program window can be minimised\n");
		strcat_s(about, 1024, "and sending will continue normally.\n\n");

		SetDlgItemTextA(hDlg, IDC_ABOUT_TEXT, (LPCSTR)about);

		// Spout website hyperlink hand cursor
		cursorHand = LoadCursor(NULL, IDC_HAND);
		hwnd = GetDlgItem(hDlg, IDC_SPOUT_URL);
		SetClassLongPtrA(hwnd, GCLP_HCURSOR, (LONG_PTR)cursorHand);
		return (INT_PTR)TRUE;

	case WM_DRAWITEM:
		// The blue hyperlink
		lpdis = (LPDRAWITEMSTRUCT)lParam;
		if (lpdis->itemID == -1) break;
		SetTextColor(lpdis->hDC, RGB(6, 69, 173));
		switch (lpdis->CtlID) {
		case IDC_SPOUT_URL:
			DrawTextA(lpdis->hDC, "https://spout.zeal.co", -1, &lpdis->rcItem, DT_LEFT);
			break;
		default:
			break;
		}
		break;

	case WM_COMMAND:

		if (LOWORD(wParam) == IDC_SPOUT_URL) {
			// Open the website url
			sprintf_s(tmp, MAX_PATH, "http://spout.zeal.co");
			ShellExecuteA(hDlg, "open", tmp, NULL, NULL, SW_SHOWNORMAL);
			EndDialog(hDlg, 0);
			return (INT_PTR)TRUE;
		}

		if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
		{
			EndDialog(hDlg, LOWORD(wParam));
			return (INT_PTR)TRUE;
		}
		break;
	}
	return (INT_PTR)FALSE;
}

// That's all and there is no more ..
